<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gravity Master - Realistic 3D Physics Challenge</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500&display=swap');
    
    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
    }
    
    canvas {
      display: block;
      box-shadow: 0 0 50px rgba(0, 255, 150, 0.2);
    }
    
    #ui {
      position: absolute;
      left: 20px;
      top: 20px;
      color: #00ff96;
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.9));
      padding: 15px 20px;
      border-radius: 15px;
      border: 2px solid rgba(0, 255, 150, 0.3);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    #scoreboard {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #fff;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.9));
      padding: 20px 25px;
      border-radius: 15px;
      border: 2px solid rgba(255, 215, 0, 0.4);
      font-family: 'Orbitron', monospace;
      text-align: right;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      min-width: 200px;
    }
    
    .score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .score-label {
      font-size: 12px;
      color: #ccc;
      font-weight: 300;
    }
    
    .score-value {
      font-size: 16px;
      font-weight: 700;
      color: #ffd700;
    }
    
    .timer-value {
      color: #00ff96;
      font-size: 18px;
    }
    
    .speed-value {
      color: #ff6b6b;
    }
    
    .high-score {
      color: #ff4757 !important;
      font-size: 18px;
      text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
    }
    
    #warning {
      color: #ff4757;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(255, 71, 87, 0.8);
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 26, 46, 0.95));
      color: #fff;
      font-size: 20px;
      flex-direction: column;
      visibility: visible;
      backdrop-filter: blur(20px);
    }
    
    h1 {
      font-family: 'Orbitron', monospace;
      font-size: 3em;
      font-weight: 900;
      background: linear-gradient(45deg, #00ff96, #ffd700, #ff6b6b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 30px;
      text-shadow: 0 0 30px rgba(0, 255, 150, 0.5);
    }
    
    .game-subtitle {
      font-size: 1.2em;
      color: #ccc;
      margin-bottom: 40px;
      font-weight: 300;
    }
    
    .controls-section {
      display: flex;
      gap: 30px;
      margin: 30px 0;
      align-items: center;
    }
    
    .difficulty-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    label {
      color: #00ff96;
      font-family: 'Orbitron', monospace;
      font-weight: 500;
      font-size: 16px;
    }
    
    select {
      padding: 12px 20px;
      font-size: 16px;
      border: 2px solid #00ff96;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-family: 'Orbitron', monospace;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    select:hover {
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(0, 255, 150, 0.3);
    }
    
    button {
      padding: 15px 30px;
      font-size: 18px;
      margin: 10px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    #start-btn {
      background: linear-gradient(45deg, #00ff96, #00d4ff);
      color: #000;
      box-shadow: 0 5px 20px rgba(0, 255, 150, 0.4);
      transform: scale(1.1);
    }
    
    #start-btn:hover {
      transform: scale(1.2);
      box-shadow: 0 8px 30px rgba(0, 255, 150, 0.6);
    }
    
    #restart-btn {
      background: linear-gradient(45deg, #ff6b6b, #ffd700);
      color: #000;
      box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
    }
    
    #restart-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 30px rgba(255, 107, 107, 0.6);
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin: 30px 0;
      padding: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .stat-item {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stat-label {
      font-size: 12px;
      color: #999;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #ffd700;
    }
    
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }
    
    .particle {
      position: absolute;
      background: radial-gradient(circle, rgba(0, 255, 150, 0.8) 0%, transparent 70%);
      border-radius: 50%;
      animation: float 6s infinite linear;
    }
    
    @keyframes float {
      0% {
        transform: translateY(100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(-10vh) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div id="ui">
    <div style="color: #ffd700; font-weight: 700; margin-bottom: 10px;">CONTROLS</div>
    <div>üöÄ WASD / Arrows: Move</div>
    <div>üåå Space: Jump</div>
    <div style="margin-top: 10px; color: #00ff96;">Knock boxes off the platform!</div>
  </div>
  
  <div id="scoreboard">
    <div class="score-row">
      <span class="score-label">‚è±Ô∏è TIME</span>
      <span class="score-value timer-value" id="time">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">‚ö° SPEED</span>
      <span class="score-value speed-value" id="speed">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">üèÜ SCORE</span>
      <span class="score-value" id="score">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">üëë HIGH SCORE</span>
      <span class="score-value high-score" id="highscore">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">üìä LAST SCORE</span>
      <span class="score-value" id="prevscore">0</span>
    </div>
    <div id="warning"></div>
  </div>
  
  <div id="overlay">
    <h1>GRAVITY MASTER</h1>
    <div class="game-subtitle">Ultimate 3D Physics Challenge</div>
    
    <div class="controls-section">
      <div class="difficulty-section">
        <label>üéØ DIFFICULTY LEVEL</label>
        <select id="difficulty">
          <option value="easy">üü¢ ROOKIE (90s)</option>
          <option value="medium" selected>üü° WARRIOR (60s)</option>
          <option value="hard">üî¥ LEGEND (45s)</option>
          <option value="insane">‚ö´ INSANE (30s)</option>
        </select>
      </div>
    </div>
    
    <button id="start-btn">üöÄ START MISSION</button>
    
    <div id="gameover-text" style="margin-top: 30px; font-size: 1.5em; text-align: center;"></div>
    
    <div class="stats-grid" id="final-stats" style="display: none;">
      <div class="stat-item">
        <div class="stat-label">BOXES DESTROYED</div>
        <div class="stat-value" id="final-boxes">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">TIME SURVIVED</div>
        <div class="stat-value" id="final-time">0s</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">MAX SPEED</div>
        <div class="stat-value" id="final-speed">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">ACCURACY</div>
        <div class="stat-value" id="final-accuracy">0%</div>
      </div>
    </div>
    
    <button id="restart-btn" style="display:none;">üîÑ PLAY AGAIN</button>
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
  import RAPIER from 'https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.18.1/rapier.mjs';
  await RAPIER.init();

  // Create floating particles
  function createParticles() {
    const container = document.getElementById('particles');
    setInterval(() => {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.width = Math.random() * 4 + 2 + 'px';
      particle.style.height = particle.style.width;
      particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
      container.appendChild(particle);
      setTimeout(() => particle.remove(), 6000);
    }, 500);
  }
  createParticles();

  // Scene setup with realistic lighting
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a1a);
  scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);
  
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0, 8, 15);
  
  const renderer = new THREE.WebGLRenderer({ 
    antialias: true,
    powerPreference: "high-performance"
  });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.body.appendChild(renderer.domElement);
  
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Realistic lighting setup
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
  sunLight.position.set(10, 20, 10);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 50;
  sunLight.shadow.camera.left = -20;
  sunLight.shadow.camera.right = 20;
  sunLight.shadow.camera.top = 20;
  sunLight.shadow.camera.bottom = -20;
  
  const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
  const fillLight = new THREE.PointLight(0x00ff96, 0.5, 30);
  fillLight.position.set(-10, 5, 10);
  
  scene.add(sunLight, ambientLight, fillLight);

  // Realistic materials with PBR
  const groundMat = new THREE.MeshStandardMaterial({ 
    color: 0x2d5a27,
    roughness: 0.8,
    metalness: 0.1,
    normalMap: null // Could add texture here
  });
  
  const boxMat = new THREE.MeshStandardMaterial({ 
    color: 0x8B4513,
    roughness: 0.7,
    metalness: 0.2
  });
  
  const playerMat = new THREE.MeshStandardMaterial({ 
    color: 0xff6b35,
    roughness: 0.3,
    metalness: 0.7,
    emissive: 0x331100
  });

  let world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
  const meshToBody = new Map();

  // Create realistic ground with texture-like appearance
  const groundGeo = new THREE.BoxGeometry(25, 1, 25);
  const groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.position.set(0, -0.5, 0);
  groundMesh.receiveShadow = true;
  scene.add(groundMesh);
  world.createCollider(RAPIER.ColliderDesc.cuboid(12.5, 0.5, 12.5));

  let player;
  function createPlayer() {
    const radius = 0.7;
    const geo = new THREE.SphereGeometry(radius, 32, 24);
    const mesh = new THREE.Mesh(geo, playerMat);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    const rbDesc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(0, 3, 0)
      .setLinearDamping(0.5)
      .setAngularDamping(0.8);
    const body = world.createRigidBody(rbDesc);
    world.createCollider(RAPIER.ColliderDesc.ball(radius)
      .setRestitution(0.3)
      .setFriction(0.9), body);
    meshToBody.set(mesh, body);
    return { mesh, body, radius };
  }

  let boxes = [];
  let totalBoxesSpawned = 0;
  
  function spawnBoxes() {
    boxes.forEach(m => { 
      const b = meshToBody.get(m); 
      if (b) world.removeRigidBody(b); 
      scene.remove(m); 
      meshToBody.delete(m); 
    });
    boxes = [];
    
    const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const boxCount = currentDifficulty === 'insane' ? 12 : currentDifficulty === 'hard' ? 10 : 8;
    
    for (let i = 0; i < boxCount; i++) {
      const m = new THREE.Mesh(geo, boxMat);
      const x = (Math.random() - 0.5) * 10;
      const y = 1.2 + i * 1.3;
      const z = (Math.random() - 0.5) * 6;
      m.position.set(x, y, z);
      m.castShadow = true;
      m.receiveShadow = true;
      scene.add(m);
      
      const rb = world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(x, y, z));
      world.createCollider(RAPIER.ColliderDesc.cuboid(0.6, 0.6, 0.6)
        .setDensity(1.2)
        .setFriction(0.8)
        .setRestitution(0.4), rb);
      meshToBody.set(m, rb);
      boxes.push(m);
    }
    totalBoxesSpawned = boxCount;
  }

  // Game state and UI elements
  const scoreEl = document.getElementById('score');
  const highscoreEl = document.getElementById('highscore');
  const prevscoreEl = document.getElementById('prevscore');
  const timeEl = document.getElementById('time');
  const speedEl = document.getElementById('speed');
  const warningEl = document.getElementById('warning');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');
  const difficultySelect = document.getElementById('difficulty');
  const gameoverText = document.getElementById('gameover-text');
  const finalStats = document.getElementById('final-stats');

  let score = 0;
  let highscore = Number(localStorage.getItem('gravity_master_highscore') || 0);
  let prevScore = 0;
  let currentSpeed = 0;
  let maxSpeed = 0;
  let boxesDestroyed = 0;
  let timeSurvived = 0;
  
  highscoreEl.textContent = highscore;

  let PLAYER_SPEED = 6;
  let JUMP_IMPULSE = 7;
  let timeLeft = 60;
  let gameOver = true;
  let currentDifficulty = 'medium';
  let gameStartTime = 0;

  function updateScore(points) {
    score += points;
    scoreEl.textContent = score;
    if (score > highscore) {
      highscore = score;
      highscoreEl.textContent = highscore;
      localStorage.setItem('gravity_master_highscore', highscore);
    }
  }

  // Enhanced controls
  const keys = { forward: 0, right: 0, jump: false };
  
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyW' || e.code === 'ArrowUp') keys.forward = 1;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') keys.forward = -1;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = 1;
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.right = -1;
    if (e.code === 'Space') { e.preventDefault(); keys.jump = true; }
  });
  
  window.addEventListener('keyup', e => {
    if (e.code.includes('Arrow') || e.code.includes('KeyW') || e.code.includes('KeyS')) keys.forward = 0;
    if (e.code.includes('Arrow') || e.code.includes('KeyA') || e.code.includes('KeyD')) keys.right = 0;
    if (e.code === 'Space') keys.jump = false;
  });

  function syncMeshFromBody(mesh, body) {
    const t = body.translation();
    const q = body.rotation();
    mesh.position.set(t.x, t.y, t.z);
    mesh.quaternion.set(q.x, q.y, q.z, q.w);
  }
  
  function isPlayerOnGround() {
    const origin = player.body.translation();
    return world.castRay(
      new RAPIER.Vector3(origin.x, origin.y, origin.z), 
      new RAPIER.Vector3(0, -1, 0), 
      player.radius + 0.1, 
      true
    ) !== null;
  }

  function startGame() {
    currentDifficulty = difficultySelect.value;
    
    // Set difficulty parameters
    switch(currentDifficulty) {
      case 'easy': PLAYER_SPEED = 5; timeLeft = 90; JUMP_IMPULSE = 6; break;
      case 'medium': PLAYER_SPEED = 7; timeLeft = 60; JUMP_IMPULSE = 7; break;
      case 'hard': PLAYER_SPEED = 9; timeLeft = 45; JUMP_IMPULSE = 8; break;
      case 'insane': PLAYER_SPEED = 12; timeLeft = 30; JUMP_IMPULSE = 9; break;
    }

    // Reset game state
    score = 0;
    currentSpeed = 0;
    maxSpeed = 0;
    boxesDestroyed = 0;
    gameStartTime = performance.now() / 1000;
    
    scoreEl.textContent = 0;
    speedEl.textContent = 0;
    prevscoreEl.textContent = prevScore;
    warningEl.textContent = '';
    gameOver = false;
    overlay.style.visibility = 'hidden';
    restartBtn.style.display = 'none';
    finalStats.style.display = 'none';
    
    // Clean up existing objects
    meshToBody.forEach((body, mesh) => { 
      world.removeRigidBody(body); 
      scene.remove(mesh); 
    });
    meshToBody.clear();
    
    // Create new game objects
    player = createPlayer();
    spawnBoxes();
  }

  function triggerGameOver(reason) {
    gameOver = true;
    prevScore = score;
    timeSurvived = Math.round((performance.now() / 1000) - gameStartTime);
    
    const accuracy = totalBoxesSpawned > 0 ? Math.round((boxesDestroyed / totalBoxesSpawned) * 100) : 0;
    
    // Update final stats
    document.getElementById('final-boxes').textContent = boxesDestroyed;
    document.getElementById('final-time').textContent = timeSurvived + 's';
    document.getElementById('final-speed').textContent = Math.round(maxSpeed);
    document.getElementById('final-accuracy').textContent = accuracy + '%';
    
    gameoverText.innerHTML = `
      <div style="color: #ff4757; margin-bottom: 20px;">${reason}</div>
      <div style="color: #ffd700;">Final Score: ${score}</div>
      ${score === highscore && score > 0 ? '<div style="color: #00ff96; margin-top: 10px;">üéâ NEW HIGH SCORE! üéâ</div>' : ''}
    `;
    
    overlay.style.visibility = 'visible';
    restartBtn.style.display = 'inline-block';
    finalStats.style.display = 'grid';
  }

  startBtn.onclick = startGame;
  restartBtn.onclick = startGame;

  // Enhanced game loop
  let lastTime = performance.now() / 1000;
  let lastBoxCount = 0;
  
  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now() / 1000;
    const dt = Math.min(now - lastTime, 0.032);
    lastTime = now;

    if (!gameOver && player) {
      // Update timer
      timeLeft -= dt;
      const displayTime = Math.max(0, Math.ceil(timeLeft));
      timeEl.textContent = displayTime + 's';
      
      // Timer warnings
      if (timeLeft <= 10 && timeLeft > 5) {
        warningEl.textContent = `‚ö†Ô∏è HURRY! ${displayTime}s LEFT`;
      } else if (timeLeft <= 5 && timeLeft > 0) {
        warningEl.textContent = `üö® CRITICAL! ${displayTime}s`;
      }
      
      if (timeLeft <= 0) {
        triggerGameOver('‚è∞ TIME\'S UP!');
      }

      // Check if player fell
      const ppos = player.mesh.position;
      if (ppos.y < -8) {
        triggerGameOver('üíÄ FELL INTO THE VOID!');
      }

      // Enhanced movement with momentum
      const vel = player.body.linvel();
      currentSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
      maxSpeed = Math.max(maxSpeed, currentSpeed);
      speedEl.textContent = Math.round(currentSpeed);
      
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      const move = new THREE.Vector3();
      
      move.addScaledVector(forward, keys.forward);
      move.addScaledVector(right, keys.right);
      
      if (move.lengthSq() > 0.0001) {
        move.normalize().multiplyScalar(PLAYER_SPEED);
        const dampingFactor = 0.85;
        player.body.applyImpulse(new RAPIER.Vector3(
          (move.x - vel.x) * dampingFactor, 
          0, 
          (move.z - vel.z) * dampingFactor
        ), true);
      }
      
      if (keys.jump && isPlayerOnGround()) {
        player.body.applyImpulse(new RAPIER.Vector3(0, JUMP_IMPULSE, 0), true);
      }

      // Check for boxes that fell off
      boxes = boxes.filter(box => {
        if (box.position.y < -5) {
          const body = meshToBody.get(box);
          if (body) world.removeRigidBody(body);
          scene.remove(box);
          meshToBody.delete(box);
          boxesDestroyed++;
          updateScore(15); // More points per box
          return false;
        }
        return true;
      });

      // Bonus points for surviving
      if (Math.floor(now) % 5 === 0 && Math.floor(now) !== Math.floor(lastTime)) {
        updateScore(1);
      }

      // Win condition - all boxes destroyed
      if (boxes.length === 0 && totalBoxesSpawned > 0) {
        const bonus = Math.floor(timeLeft * 2);
        updateScore(bonus);
        triggerGameOver(`üèÜ LEVEL COMPLETE! +${bonus} TIME BONUS`);
      }
    }

    // Physics step
    world.step();

    // Sync all physics objects
    for (const [mesh, body] of meshToBody.entries()) {
      syncMeshFromBody(mesh, body);
    }

    // Enhanced camera following with smooth movement
    if (player) {
      const ppos = player.mesh.position;
      const vel = player.body.linvel();
      
      // Predict player movement for smoother camera
      const predictedPos = new THREE.Vector3(
        ppos.x + vel.x * 0.3,
        ppos.y + vel.y * 0.2,
        ppos.z + vel.z * 0.3
      );
      
      const camTarget = new THREE.Vector3(predictedPos.x, predictedPos.y + 2, predictedPos.z);
      const desiredCamPos = camTarget.clone().add(new THREE.Vector3(0, 6, 12));
      
      // Smooth camera interpolation
      camera.position.lerp(desiredCamPos, 0.05);
      camera.lookAt(camTarget);
    }

    // Add some dynamic lighting effects
    fillLight.intensity = 0.5 + Math.sin(now * 2) * 0.1;
    fillLight.color.setHSL(0.3 + Math.sin(now) * 0.1, 0.8, 0.5);

    renderer.render(scene, camera);
  }
  
  animate();
  </script>
</body>
</html>